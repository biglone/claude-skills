---
name: autonomous-dev
description: 自主开发模式。让 AI 自主完成完整开发任务，无需每步确认。当用户要求"自主开发"、"自动完成"、"全自动"时使用。
allowed-tools: Read, Write, Edit, Bash, Grep, Glob, Task
---

# 自主开发模式

在单次会话内自主推进开发任务，默认连续执行，不在每个小步骤都中断询问。

## 核心目标

- 快速把需求转为可运行代码。
- 完成实现、测试、审查的闭环。
- 在高风险或高不确定场景下暂停并请求确认。

## 标准执行流程

1. 需求分析
2. 方案确认（轻量）
3. 代码实现
4. 测试验证
5. 代码审查
6. 结果汇报

## 阶段执行规则

### 1) 需求分析

- 识别目标、范围、约束、验收标准。
- 标注缺失信息；若缺失阻塞执行，提出最小问题集后再继续。

### 2) 方案确认（轻量）

- 给出最小可行方案（模块、关键文件、测试策略）。
- 若方案分歧明显，列出 2-3 个选项并请求用户选择。

### 3) 代码实现

- 优先复用现有结构与代码风格。
- 仅修改完成目标所需的最小文件集合。
- 变更后立即进行本地自检（编译、lint、静态检查）。

### 4) 测试验证

- 先跑受影响范围最小的测试，再跑全量测试。
- 失败时自动修复并重试，默认最多 3 轮。
- 3 轮后仍失败，停止自动修复并报告阻塞点。

### 5) 代码审查

- 检查正确性、边界条件、异常处理、可维护性。
- 检查明显安全风险和性能回退。

### 6) 结果汇报

- 总结改动文件、关键决策、测试结果、剩余风险。
- 生成 commit message。
- 默认仅在用户明确要求时执行 `git commit`；不自动 `push`。

## 提交策略（重要）

- 若用户已给出提交节奏偏好（例如“每个功能改完就提交”“小步提交”），必须遵循该偏好覆盖默认规则。
- 采用“单一功能单提交”：每次提交只包含一个可独立描述的功能或修复，避免把多个功能混在同一提交。
- 每次提交前至少完成该功能对应的最小验证（受影响测试/关键命令），并在汇报中说明验证结果。
- 若当前改动跨多个功能，先拆分并分批提交，再继续下一功能开发。
- 用户未要求 `push` 时，始终不执行远程推送操作。

## 自动继续与暂停条件

### 自动继续

- 需求清晰且无高风险操作。
- 错误可在当前上下文直接修复。
- 修复后验证通过。

### 必须暂停并询问用户

- 需求存在关键歧义。
- 需要在多个可行方案中做产品或架构决策。
- 涉及批量删除、数据库不可逆变更、敏感配置修改。
- 自动修复已达到重试上限。

## 输出格式

### 进度汇报模板

```text
[阶段 X/6] ✅ {阶段名}
- 关键动作: {action}
- 结果: {result}
- 下一步: {next}
```

### 最终汇报模板

```text
✅ 自主开发完成

任务: {task_summary}
改动文件:
- {path}: {reason}

验证结果:
- Lint: {status}
- Tests: {status}

风险与后续:
- {risk_or_followup}
```

## 触发方式

- "自主开发 {任务描述}"
- "自动完成 {任务描述}"
- "全自动模式 {任务描述}"
- "autonomous mode: {task}"

## 渐进加载（按需读取）

仅在命中对应场景时再读取参考文档，避免主技能上下文过重。

- 进度恢复、断点续跑、检查点、状态查询、手动介入：读取 `references/progress-and-recovery.md`
- 敏感文件保护、危险操作确认、安全审计、紧急处理：读取 `references/security-and-emergency.md`

## 与其他 Skills 协作

- 需要自动化质检流水线时，交给 `auto-code-pipeline`。
- 需要持续修复直到通过时，交给 `auto-fix-loop`。
- 需要补测试时，交给 `test-generator`。
- 需要独立审查结论时，交给 `code-reviewer`。
